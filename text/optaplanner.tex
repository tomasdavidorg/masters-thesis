V této kapitole se zaměříme na planning engine Optaplanner. Jedná se software určený k řešení plánovacích problémů. OptaPlanner je opensource projekt vyvíjený JBoss comunitou od roku 2006 a je součástí Drools projektu. Kombinuje optimalizační algoritmy s jádrem pravidlového engine (Drools Expert). 

V sekci \ref{planningProblem} si blíže ukážeme co je to plánovací problém, sekce \ref{plannerConf} a \ref{score} zmíní konfiguraci optaplanneru a ukážeme si co je to skóre a jaké jsou možnosti jeho výpočtu. Na závěr v sekci \ref{optimalAlg} zmíníme optimalizační algoritmy které je možno použít.

\section{Planning problem}\label{planningProblem}
V běžném životě, v práci či při jiných příležitostech se setkáváme s problémy, ke kterým máme omezené prostředky (čas, peníze, apod.), stejně tak organizace musí čelit problémům na které mají např. jen omezený počet zaměstnanců. OptaPlanner slouží k optimalizaci takovýchto plánovaní a ke zvýšení efektivnosti za cenu snížení nákladů.

Plánovací problém je v nástroji reprezentován Java třídami. Základním plánovacím problémem může být N-queen problem, mezi problémy z reálného života pak můžeme zařadit např. Vehicle routing problem,  Course timetabling nebo Hospital bed planning.

N-queen problém, ač není příliš z reálného světa je vhodný jako příklad. Na šachovém poli o velikosti n je rozestavěno n dam. Dáma se může pohybovat horizontálně vertikálně a do úhlopříčky. V tomto problému se snažíme dosáhnout toho aby žádná z dam neohrožovala jinou. 

\section{Planner configuration}\label{plannerConf}
Planner configuration se dá rozdělit na pět základních kroků, které jsou potřeba udělat před získáním řešení. Tyto kroky jsou:
\begin{enumerate}
\item \textbf{Namodelování plánovacího problému} -- vytvoření třídy, která ipmlementuje rozhraní Solution, tříd plánovacích entit a plánovacích proměnných
\item \textbf{Konfigurace Solveru} -- spočívá v nastavení pravidel a algoritmů řešeného problému
\item \textbf{Náhrání data setu problému} -- přirazení instancí plánovacích entit a proměnných
\item \textbf{Spuštění Solveru} -- zapnutí mechanismu pro řešení problému
\item \textbf{Získání nejlepšího řešení} -- vyvolání metody, která vrátí nejlepší získané řešení.
\end{enumerate}

\subsection{Namodelování plánovacího problému}
Při modelování plánovacího problému je dobré si ujasnit co je plánovací fakt a co entita. Problem fakt se během plánování nemění tedy jeho hodnoty zůstávají stále stejné. Oproti tomu je plánovací entita \todo{dodělat}
 
\subsubsection{Problem fact}
Problem fact je třída, která obsahuje getry vracející určité vlastnosti(property) této třidy. Třída se během plánování nemění. V případě n-Queen problému jsou řádky a sloupce problem facts. Problem fact neobsahuje žádný specifický optaplanner kód.

\subsubsection{Planning entity}
Planning entity je třída, která se během plánování mění. V případě n-Queen problému se jewdná o třídu Queen, která mění svoji pozici na určitém řádu. Plánovací entita musí být označena @PlanningEntity anotací. Každá plánovací entita má 1 nebo více plánovacích promenných. \todo{opravit} V tomto případě je třída Queen definována 2 problem fakty - řádkeem a sloupcem a z toho je řádek právě plánovací proměnná. Dále je ještě potřeba do konfigurace solveru označit tuto planning entity třídu.

\subsubsection{Planning variable}
Plánoovací proměnná je vlastnost planning entity třídy s potřebnými getry a setry. V připadě našeho n-Queen problému se jendná o řádek který je plánovací proměnná. Plánovací proměnná musí být označena @PlanningVariable anotací, která obsahuje valueRangeProviderRefs property. Tato property definuje jaké jsou možné hodnoty plánovací proměnné. \todo{spojit s @ValueRangeProvider id'}

\subsubsection{Planning value and planning value ranges}
Planning value je možná hodnota pro plánovací proměnnou. Obvykle je plánovací hodnota problem fakt ale může také být jiný objekt nebo hodnota typu double atd. Planning value range je množina pánovacícch hodnot a proměnných. Tato množina může být počitatelná (např. řádek 1, 2, 3 nebo 4) nebo nepočitatelná (double mezi 0.0 a 1.0).

Value Range je označen @ValueRangeProvider anotací, která má property id, které se odkazuje na  @PlanningVariable's property valueRangeProviderRefs. Anotace může být na dvou typech metod - na solution nebo na plánovací entitě, a její návratový typ je buď kolekce možných hodnot nebo jsou to hranice hodnot.  

\subsubsection{Planning problem and planning solution}
Každý plánovací problém musí zabalen jako třída, kterou poté solver využívá pro řešení problému. V případě n-Queens problému třída musí obsahovat Column, row, a queen list.
Plánovací problém je nevyřešené plánovací řešení. Toto řešení musí být popsáno třídou který implementuje Solution rozhraní. Toto rozhraní vyžaduje implementovat metody setScore a getScore a metodu getProblemFacts. \todo{Popsat více Solution interface}

\subsection{Konfigurace Solveru}
Konfigurace solveru probíhá pomocí konfiguračního XML souboru. V podstatě se dá rozdělit na tři části:
\begin{enumerate}
\item Definování modelu -- obsahuje jména třídy, která implementuje třídu solution a třídu která zastupuje v plánvacím problému plánovací entitu
\item Definování score funkce -- základními parametry jsou typ skóre a třída pro výpočet skóre (resp soubor drl s pravidly podle kterých se skóre počítá)
\item Konfigurace optimalizačních algoritmů -- obsahuje nastavení algoritmů, které se využijí pro výpočet řešení daného problému
\end{enumerate}
Konfigurace může být také změněna dynamicky za běhu pomocí SolverConfig API. Je tak například možné získat aktuální nastavení, či nastavení změnit.

\subsection{Náhrání data setu problému}
Ještě před samotným spuštením je potřeba nahrát potřebná data. Toto se provádí nahráním plánovacích entit a nastavení planning values do patřičných kolekcí tříd která implementuje rozhraní Solution. Nyní již je vše připraveno pro spuštění.

\subsection{Spuštění solveru a získání nejlepšího řešení}
Spuštění solveru probíha jednoduše zavoláním metody solve() s parametrem odkazu na istanci třídy implementující rozhraní solution. Po ukončení výpočtu a zavoláním metody getBestSolution získáme nejlepší nalezené řešení. V případě n-Queen problému nám vrátí řešení kde každá královna má přiřazený jeden řádek a v případě, že nalezla optimální řešení tak se žádné dvě královny neohrožují.

\section{Score}\label{score}
Score je způsob jak porovnat dvě solutions. Každé solution má své scóre a solution s větším scóre je lepší. Solver hledá řešení s co nejvyšším scóre, tomuto řešení se pak říká nejlepší nalezené řešení. Optimální řešení je však nejlepší řešení daného problému. To může Solver samozřejmě také nalézt a v tom případě je nejlepší řešení zároveň i optimální řešení. Exisutje několik technik jak počítat scóre:
\begin{itemize}
\item Score constraint signum -- založené na omezeních, u positive constraint se snažíme získat co nejvyšší scóre, a u negative constraints se snažíme snížit zápornou hodnotu scóre
\item Score constraint weight -- všechny pomínky nemusí mít stejnou váhu a proto je někdy potřeba počítat s tím že jedna podmínka je několikrát důležitější než jiná
\item Score level -- některé scóre jsou důležitější než jiné a proto můžeme porovnávat první podle dúležitějšího (hard) score a pak se rozhodnout až podle minoritního (soft) scóre
\item Pareto scoring -- různé typy podmínek nemají proti sobě metr proto se porovnávají indoviduálně a scóre s vyšší dominací bude lepší řešení
\item Kombinace různých typů -- také se můžou jednotlivé typy kombinovat
 
\end{itemize}

\subsection{Score calculation}
Výpočet scóre každého solution může být prováděno několika způsoby: 
\begin{itemize}
\item Easy Java score calculation -- výpočet probíhá za pomocí jedinné metody, která vrací skóre pro dané soliton, to poskytuje jednoduchost výočtu ale za cenu pomalejšího výpočtu (pomocí rozhraní EasyScoreCalculator)
\item Incremental Java score calculation -- výpočet probíhá pomocí několika výočetních metod, jedná se o rychlejší řešení ale složitší na implementaci (rozhraní IncrementalScoreCalculator)
\item Drools score calculation -- výpočet za pomocí DRL pravidel, dobře optimalizovatelné ale za cenu použítí DRL jazyka
\end{itemize}

\section{Optimization algorithms}\label{optimalAlg}
Každý výpočet jednotlivé solution zabírá určitou dobu, jenže OptaPlanner nepočítá pouze jedno solution ale hledá to nejlepší a řešení může být opravdu mnoho a prohledávaný prostor může narůst do astronomických rozměrů a s tím i doba výpočtu. Tato práce si neklade za cíl popisovat algoritmy pouze jednotlivé nastíníme. Více informací je pak možno získat na Optaplanner doc.

Mezi algoritmy které je možné v nástroji OptaPlanner použít např. patří:
\begin{itemize}
\item Exhaustive Search -- Brute Force,  Branch And Bound
\item Construction heuristics --  First Fit, Weakest Fit,  Strongest Fit, \dots
\item Metaheuristics
\begin{itemize}
\item Local Search --  Hill Climbing, Tabu Search, Tabu Search, \dots
\item Evolutionary Algorithms -- Evolutionary Strategies, Genetic Algorithms
\end{itemize}
\end{itemize}

\subsection{Solver structure}
Solver se může skládat z jedné až několika fázi. Podle toho kolik optimalizačních algoritmů použijeme tolik Solver bude mít fází. Pouze jedna fáze může běžet v jeden okamžit a  každá z fází se skládá z několika stepů. Jeden krok se pak dále skládá z několik move. Move je nenižší část solveru. Jedná se o změnu plánovací entity. V případě n-Queen problému se tedy jedná o přesunuti královny na jiný řádek.  

\subsection{Termination}
Ne každá fáze Solveru se automaticky ukončí a proto je někdy potřeba přidat podmínky při jakých se má výpočet ukončit. Možnosti jakými můžeme fázi zastavit jsou následující:
\begin{itemize}
\item Ukončení časovým limitem -- k ukončení dojde při dovršení časového limitu, rozhsah tohoto limitu je od milisekund po hodiny
\item Při nalezení nejlepšího scóre -- specifikací nejlepšího scóre můžeme docílit ukončení když se toho skóre dosáhne
\item Ukončení po počtu kroků -- ukonči se po dovršení limiti počtu kroků
\item Kombinací jednotlivých ukončení -- také je možné ředchozí ukončení kombinovat
\item Asynchronní ukončení z jiného vlákna -- pokud je potřeba ukončit výpočet dřivé než automatizovanými metodami je možné to udělat z jiného vlákna
\end{itemize}


